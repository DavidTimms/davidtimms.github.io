[ { "title": "Seven Days of OCaml", "url": "/programming-languages/ocaml/2022/01/19/seven-days-of-ocaml.html", "categories": "programming-languages, ocaml", "tags": "", "date": "2022-01-19 00:00:00 +0000", "snippet": "A few weeks ago, I returned from an ill-advised excursion to London to discover that I had picked up COVID-19. Whoops. Luckily my symptoms were very mild, but I still had to remain in self-isolation for ten days. What better way to fill this gaping void of time than learning a new programming language by tackling some Advent of Code puzzles?OCaml is a language which has been on my radar for a few years, particularly since listening to the excellent Signals and Threads podcast from Jane Street. I wanted to compare it to the other functional languages I’ve used, Scala and Haskell. The idea of an mature language in the ML family which is more focussed on pragmatism than purity and category theory appealed to me.As somebody who rather enjoys implementing programming languages, I also wanted to see whether OCaml would be a good candidate for future projects in that space. Its combination of language features, performance and libraries make it particularly suited to writing compilers. That’s why Graydon Hoare chose it for the original Rust compiler, and Facebook for the Hack compiler.I only completed the first seven puzzles in this year’s calendar, but it now feels like I’ve seen enough to form an initial opinion though. I am still very much a novice though - experienced OCamlers would cringe at my code, I’m sure.The GoodThe OCaml compiler is fast. Admittedly, my program was not very large, but even after pulling in a couple of sizable libraries from opam, builds are near instant - under a second for a clean build, and around 100ms for an incremental build. After using TypeScript and Scala for a couple of years, this is a fresh of fresh air. The faster feedback loop makes the development experience much more pleasant. As with other statically-typed languages, I do find that I need to run my code less frequently while developing than I do in dynamic languages. That means the fast compile times are merely a nice-to-have, rather than being essential for productivity, but they are welcome nonetheless.Another aspect of the developer experience which I enjoyed was the VSCode plugin. This works well out-of-the-box, and provides responsive type-checking as you type. It can display type annotations above let declarations, which I found particularly useful when relying on the inferred types instead of specifying them explicitly.Not only is the compiler faster than many of its peers, but its Hindley-Milner type inference algorithm is the most effective I have ever used. It feels almost magical to write a non-trivial program with no type annotations and have the compiler derive precise and correct static types throughout. In practice, I found that I usually did want to explicitly provide parameter and return types, but for my benefit, not the compiler’s. I prefer to write a function by thinking about the input and output types first, then tackling the implementation later.Having written functional-style code in languages where it is not the primary paradigm (TypeScript, Python), it feels great to use a language like OCaml which makes those patterns easy and elegant. The built-in immutable list, map and set data structures meant I didn’t need to worry about accidental mutation or cloning. They are a joy to manipulate with higher-order functions (e.g. map, filter, fold, sum, find), especially when combined with universal currying. I’m still not 100% sold on the merits of curried functions though - they can certainly lead to some beautiful and concise code, but as you get further towards full point-free style, it can become impenetrably dense. I would rather a function which is twice as long, if it takes half the time to understand. As always, good judgement and a little restraint go a long way.OCaml’s pattern matching is simple, but effective. Modelling data with ADTs then manipulating them with pattern matching functions is such a good fit for the types of puzzles in Advent of Code. In Scala, I have found that this style can be just as effective on more complex “real world” problems, and I look forward to tackling some of those in OCaml in future.The language’s syntax was something I did not expect to like. Facebook thought OCaml’s syntax was so unintuitive that they created an alternative syntax, Reason, to make it look more like JavaScript. The syntax is certainly unfamiliar for anybody used to C family languages, but I found it easy to pick up. The core of the language is quite small, and once I had exorcised my TypeScript muscle memory, I had few problems. Where I did make mistakes, they were picked up by the compiler. In a statically-typed language, it is actually quite hard to make a syntax error which leads to unexpected behaviour at runtime.Having spent years writing Python, I am a big fan of optional and named parameters, so it was a nice surprise to find both present in OCaml. I think these features are a big part why I find OCaml easier to read than Haskell. I was using Jane Street’s alternative standard library, base, which adds a ton of helpful functions, and uses named parameters very heavily. Personally, I think they are slightly overused there. Explicit names at the call site don’t add much clarity to generic functions like List.map.I was glad to see that the pipeline operator (|&amp;gt;) is present in OCaml. As far as I am aware, this first appeared in F♯, with variations having since appeared in Elixir, Hack, and perhaps soon JavaScript. This is such a small addition to the language, but makes a big difference to the experience of using it. It is natural to view a function as a serious of steps, laid out top to bottom, left to right, instead of having to read backwards from the most deeply nested expression. This is why “fluent” method chaining interfaces are so popular in object-oriented languages. Just like pattern matching, this feels like a feature which will become mainstream over the next few years as more languages adopt some variation of it.The BadWhile OCaml is a mature and battle-tested language, its ecosystem is small and fractured. There are some good learning resources available, such as Real World OCaml, but far fewer than for more popular languages. This may be unfounded, but I worry that once I get in to the more obscure areas of the language, finding answers and explanation online will become difficult. This isn’t helped by having two competing standard libraries, two competing syntaxes, and part of the community apparently forking to create a new language.When it comes to libraries, OCaml’s package manager lists just 3,668 packages - a far cry from the 1,841,493 JavaScript packages or 349,026 Python packages available. Obviously, quality is more important than quantity, but it does indicate that you should be prepared to write your own libraries for some areas if you choose OCaml for a serious project.When debugging, I must confess that I quite often fall back on the tried and true technique of littering the code with print calls. I found this curious hard to do in OCaml, since there is no universal string representation for data structures. I wanted to be able to print out intermediate maps, lists, sets and records to verify that my parsing was working correctly, but I was not able to find a way to do this, other than writing repetitive functions to produce string representations. Perhaps I need to find a more sophisticated method of debugging, but I longed to be able to call an equivalent of .toString() as I would in Scala or TypeScript.My frustration with converting to strings is really a symptom of a much wider limitation - the lack of ad-hoc polymorphism. Other languages have different features to solve this problem - Haskell has type classes, Rust has traits, Scala has implicits. These all work in a similar way - by allowing operations on a type to be looked up and passed to a function implicitly by the compiler. This allows generic functions to do useful things with the parameters they are passed. For instance, producing string representations of data types in Haskell is elegantly handled by the Text.Show type class. As OCaml has no way to do this, polymorphic functions must be fully polymorphic - able to operate on any concrete type. The most commonly suggested workaround is to explicitly provide a first-class module. This does work, but it requires quite a bit of boilerplate and clutters the call site. I found the standard library map and set types far harder to work with in OCaml than they are in other languages due to this.Most object-oriented languages tackle the problem by using some form of subtyping, such as interfaces, inheritance or structural types. This is a bit less flexible than type classes, but it works well enough for most use cases. While OCaml has a very capable object system, it does not feel well unified with the rest of the language. Integers are not objects. Lists are not objects. Records are not objects. This means there is no “iterable” interface for collections and no “comparable” interface for types which can be used in sets.The maintainers of OCaml are well aware of this shortcoming, and aim to eventually add modular implicits to the language. In recent years, it seems to have been deprioritised in favour of multicore and algebraic effects though. I really hope that modular implicits make it in eventually, as they would hugely improve the language’s ergonomics.The UntouchedThere are still many features of OCaml which I have not yet had an opportunity to use. These include some of its most interesting and distinct aspects, so I hope I do get a chance to explore them in a future project. Perhaps some of these could help with the pain points discussed above. The ones I am aware of are: Metaprogramming and PPX GADTs Functors and other advanced uses of the module system Classes and objectsConclusionI thoroughly enjoyed my time using OCaml. The language feels mature, approachable and productive. While I still wish it had type classes, I’m sure I’ll find better ways to cope without them as I explore further. I’m keen now to move on to some “real-world” projects - perhaps another compiler, or a web app, or a CLI tool.If you’re interested in functional programming, or, like me, you just want to give a new language a go, why not take OCaml for a spin? You might like it too." }, { "title": "Effective.ts Tutorial - Part One", "url": "/typescript/effective.ts/2021/12/23/effective-ts-tutorial-part-one.html", "categories": "typescript, effective.ts", "tags": "", "date": "2021-12-23 00:00:00 +0000", "snippet": "Effective.ts is a library I recently released, which aims to make it easier to write safe, concurrent, fault-tolerant programs in TypeScript. It takes heavy inspiration from the way side effects are handled in pure functional systems like Haskell and Cats Effect (Scala). This tutorial introduces some of the basic concepts and unique features of the library.Introducing IOThe most important concept in the library is a type called IO. An IO is an action - a fragment of a program. When it is run, it can perform side effects, like writing to disk or making HTTP requests. It is a thin wrapper around an asynchronous function, which is why it returns a promise when it is run.The best way to write programs with effective.ts is to combine these small fragments of programs together into larger more complex actions, until you have a single IO which represents your entire program. That means you only need one call to .run() which comes at very top level of the program.At this stage, it might seem like unnecessary indirection to create an IO then run in later in the program, but this separation gives us much more power to manipulate the control flow of our program, as we will see in part two.The IO type has two type parameters: A is the type of values returned when the action succeeds. E is the type of errors raised when the action fails. For now, we can omit this, and let it default to unknown. We’ll see more about handling errors later.Let’s see how we create an IO.To get started we need to import IO:import { IO } from &#39;effective.ts&#39;;The simplest way is using IO.wrap. This creates an action which will return a specific value when it is run. The action always succeeds and does not perform any side effects. Some other libraries call this function pure or return.const return123: IO&amp;lt;number&amp;gt; = IO.wrap(123);return123.run(); // return a promise which resolves to 123.That’s all well and good, but we want to perform side effects! For that we need to use the IO function.const printHi: IO&amp;lt;void&amp;gt; = IO(() =&amp;gt; console.log(&quot;Hi!&quot;));printHi.run(); // prints &quot;Hi!&quot; to the console.In the above example, console.log does not return any useful value, so the result type for the action is void.We can also create actions which perform asynchronous effects, such as network requests.import fetch, { Response } from &quot;node-fetch&quot;;const makeRequest: IO&amp;lt;Response&amp;gt; = IO(() =&amp;gt; fetch(&quot;https://www.wikipedia.org&quot;));// returns promise which resolves to a Response// object once the request is complete.makeRequest.run(); Notice that the type of makeRequest is IO&amp;lt;Response&amp;gt;, not IO&amp;lt;Promise&amp;lt;Response&amp;gt;&amp;gt;? That demonstrates something important - all actions in effective.ts are implicitly asynchronous, so the types do not distinguish between synchronous and asynchronous. You shouldn’t need to use async and await at all, or deal with promises directly. Asynchronous actions are awaited automatically by the runtime.Combining ActionsNow that we know how to build a basic action, how do we go about combining these into full programs? IO has a few methods to help.The map method can be used to transform the result of an action using a pure function. It is equivalent to the map method on an array.const mapped: IO&amp;lt;number&amp;gt; = IO.wrap(123).map(x =&amp;gt; x + 1);mapped.run(); // return a promise which resolves to 124.The andThen method is used to perform one action after another. The function which produces the second action takes the result of the first action as an argument. This function is sometimes also called flatMap or bind. It is what makes the IO type a monad.import fetch from &quot;node-fetch&quot;;const fetchWikipediaHomepage: IO&amp;lt;string&amp;gt; = IO(() =&amp;gt; fetch(&quot;https://www.wikipedia.org&quot;)) .andThen(response =&amp;gt; IO(() =&amp;gt; response.text()))// returns promise which resolves with the text of the response.fetchWikipediaHomepage.run();These features alone are enough to build up many programs. But in the real world, nothing ever goes quite to plan. It’s time to look at how we can handle those pesky errors.Handling ErrorsThe standard way of dealing with errors in TypeScript is to throw an exception, then catch it with a try/catch block. While this does work, it has a few problems. It is hard to maintain type safety in catch blocks, because the compiler does not know what kinds of exception can be thrown. That is why TypeScript uses the rather unhelpful any or unknown types for caught exceptions.The second problem comes when you call a library function. As a user of the library, it is hard to know what kinds of exceptions the function might throw. If you are lucky, this information will be described in the library documentation, and if you are very lucky, the description will be up-to-date!In effective.ts, you can “raise” an error, which is equivalent to throwing an exception. The difference is that the IO type describes in its second type parameter what types of error the action can possibly raise. This helps to make functions self-documenting.// Because the error type is &quot;never&quot;, we know this// action will never raise an error.const neverFails: IO&amp;lt;number, never&amp;gt; = IO.wrap(456);const alwaysFails: IO&amp;lt;never, TypeError&amp;gt; = IO.raise(TypeError(&quot;validation failed&quot;));// Returns a promise which rejects with the TypeError.alwaysFails.run();As we saw earlier, when we want to call outside code with side effects, we need to wrap the call in IO. This includes any code which might throw an exception. When we run the action, it will catch any exceptions which are thrown and raise them in the IO context. Since we cannot know what exceptions third-party code might throw, the error type this case defaults to unknown.const printGreeting: IO&amp;lt;void, unknown&amp;gt; = IO(() =&amp;gt; console.log(&quot;Greetings!&quot;));If you do not care about precise tracking of errors, you can leave them typed as unknown throughout the program. If you do want precision though, you can convert the unknown error to a known type. You can do this with the mapError method, which is the calamitous cousin of the map method we used previously - it transforms an error using a pure function. If the action does not raise an error, the transformer function is never called.class PrintingError extends Error { constructor(readonly cause: unknown) { super(`Failed to print to console: ${cause}`); }}const knownError: IO&amp;lt;void, PrintingError&amp;gt; = printGreeting.mapError(error =&amp;gt; new PrintingError(error));If we want to recover from an error instead of just transforming it, we need the catch method. The catcher function returns an action, so it can use IO.raise to re-raise an error or IO.wrap to return a fallback value.import fetch from &quot;node-fetch&quot;;const fetchWithCatch: IO&amp;lt;string, never&amp;gt; = IO(() =&amp;gt; fetch(&quot;https://www.wikipedia.org&quot;)) .map(() =&amp;gt; &quot;fetched successfully&quot;) .catch(error =&amp;gt; IO.wrap(&quot;failed to fetch&quot;));// returns a promise which resolves with// &quot;fetched successfully&quot; or &quot;failed to fetch&quot;.fetchWithCatch.run();In the example above, we can see that the error type for the entire fetchWithCatch action is never, meaning it will never raise an error. This is inferred because we caught any errors and did not re-raise them.When programming with effective.ts, it is important to use IO.raise instead of throwing exceptions directly, otherwise the types of the errors will not be tracked correctly.const unsafelyThrow: IO&amp;lt;Response&amp;gt; = IO(() =&amp;gt; fetch(&quot;https://www.wikipedia.org&quot;)) .andThen(response =&amp;gt; { if (response.status &amp;gt;= 400) { // BAD throw Error(&quot;Request failed&quot;); } else { return IO.wrap(response); } });const safelyRaise: IO&amp;lt;Response&amp;gt; = IO(() =&amp;gt; fetch(&quot;https://www.wikipedia.org&quot;)) .andThen(response =&amp;gt; { if (response.status &amp;gt;= 400) { // GOOD return IO.raise(Error(&quot;Request failed&quot;)) } else { return IO.wrap(response); } });We’ve now covered the basics of effective.ts. We can use IO to represent actions and combine these actions into full programs with error handling.In part two, we’ll dive in to what really makes the library special - its support for concurrency, fault-tolerance and cancellation." }, { "title": "Exploring Template Literal Types in TypeScript 4.1", "url": "/programming-languages/typescript/2020/11/20/exploring-template-literal-types-in-typescript-4.1.html", "categories": "programming-languages, typescript", "tags": "", "date": "2020-11-20 00:00:00 +0000", "snippet": "TypeScript 4.1 has just been released. This edition of the language builds on the features introduced in version 4.0 with a group of new tools which provide typesafe ways to express common dynamic JavaScript patterns. As with most powerful type system features, they can also be used and abused in weird and wonderful ways.One of the most interesting new features is template literal types. Back in ES2015, a new string syntax called a template literal was added to JavaScript, providing a convenient and readable way to insert values into strings. These are strings delimited by backticks which evaluate any expression surrounded by ${ … }, inserting the result into the string.const name = &quot;Anders&quot;;console.log(`Hello, ${name}!`); // prints &quot;Hello, Anders!&quot;console.log(`I said, HELLO ${name.toUpperCase()}!`); // print &quot;I said, HELLO ANDERS!&quot;In TypeScript 4.1, you can now use the template literal syntax in types as well as values. This means if you have a type which represents a single string literal or, more likely, a union of multiple string literals, you can use a template literal type to create a new string literal type derived from the old one.type Animal = &quot;shark&quot; | &quot;giraffe&quot; | &quot;platypus&quot;;type BabyAnimal = `baby-${Animal}`; // = &quot;baby-shark&quot; | &quot;baby-giraffe&quot; | &quot;baby-platypus&quot;As the example above shows, the transformation is distributed over the union, being applied to each member separately, then producing a union of the results. If you include multiple union types in the template literal, it produces every combination.type Animal = &quot;shark&quot; | &quot;giraffe&quot; | &quot;platypus&quot;;type Age = &quot;baby&quot; | &quot;adolescent&quot; | &quot;old&quot;;type BabyAnimal = `${Age}-${Animal}`;// = &quot;baby-shark&quot; |// &quot;baby-giraffe&quot; |// &quot;baby-platypus&quot; |// &quot;adolescent-shark&quot; |// &quot;adolescent-giraffe&quot; |// &quot;adolescent-platypus&quot; |// &quot;old-shark&quot; |// &quot;old-giraffe&quot; |// &quot;old-platypus&quot;As well as building up new string literal types from shorter pieces, we can also extract parts of the string by matching a pattern. To do this we need to combine template literal types with conditional types and the infer keyword.type ExtractVerb&amp;lt;S extends string&amp;gt; = S extends `${infer Verb} ${infer Activity}` ? Verb : never;type Verbs = ExtractVerb&amp;lt;&quot;play chess&quot; | &quot;write code&quot; | &quot;read hacker news&quot;&amp;gt;// = &quot;play&quot; | &quot;write&quot; | &quot;read&quot;This means we can break down a string into its substrings and return different types based on the contents of those substrings. That is everything we need to implement a simple parser. Let’s look at some potential applications.RoutingIn Node.js web frameworks like Express, it is common to define URL routing rules by using a path pattern given as a string. These strings can contain placeholders to represent dynamic parts of the path like IDs and slugs. Express uses a colon prefix for these path parameters. You can then access the values of these parameters in the route handler function using the object req.params.app.get(&quot;/users/:userId/posts/:postId&quot;, (req, res) =&amp;gt; { const userId = req.params.userId; const postId = req.params.posId; res.send(`Requested post ${postId} from user ${userId}`);});The code above will be perfectly acceptable to the TypeScript compiler, but if you run it, you’ll notice the server responds with something like this: Requested post undefined from user 12There is a typo in the function, but TypeScript did not complain. That is because the type of req.params is a ParamsDictionary.interface ParamsDictionary { [key: string]: string;}This type just says it is an object with string keys and string values. It knows nothing about which keys the object will actually have at runtime, so it isn’t much better than any. Template literal types allow us to parse the path to produce a safe and accurate type for req.params.First, we need a generic type which can parse our path string literal to extract the parameters preceded by a colon. At the type level, we don’t have normal data structures like arrays, so we will need to represent the parameters as a union.type PathParams&amp;lt;Path extends string&amp;gt; = Path extends `:${infer Param}/${infer Rest}` ? Param | PathParams&amp;lt;Rest&amp;gt; : Path extends `:${infer Param}` ? Param : Path extends `${infer _Prefix}:${infer Rest}` ? PathParams&amp;lt;`:${Rest}`&amp;gt; : never;It may look a little scary, but once you break it down, it’s not too bad. The first case matches parameters at the start or middle of the path.e.g. &quot;:userId/posts/:postId&quot;. The second case matches parameters at the end of the path.e.g. &quot;:postId&quot;. The third matches strings with some other content before a parameter and strips it away.e.g. &quot;/posts/:postId&quot;. In the fourth and final case where none of the three patterns match, we return the never type, because this behaves like an empty set when used like a union.In the first and third cases it recursively calls itself with a shorter section of the string.Applying this type to the path from above gives the parameter names, as we expect.type ParamNames = PathParams&amp;lt;&quot;/users/:userId/posts/:postId&quot;&amp;gt;;// = &quot;userId&quot; | &quot;postId&quot;We can use a mapped type to generate an object with those parameter names as keys.type PathArgs&amp;lt;Path extends string&amp;gt; = { [K in PathParams&amp;lt;Path&amp;gt;]: string};type Params = PathArgs&amp;lt;&quot;/users/:userId/posts/:postId&quot;&amp;gt;;// = { userId: string, postId: string }Great! That’s the type we want for req.params.Now all that is left to do is to use this type in the routing method of our web framework.const app = { get&amp;lt;P extends string&amp;gt;( path: P, handler: (req: { params: PathArgs&amp;lt;P&amp;gt; }, res: any) =&amp;gt; void, ): void { // web framework goes here... } // other methods...};NOTE: In a real implementation, req would have many other properties and res would be strongly typed. I have omitted those details to simplify this example.Now, the compiler catches the typo in our route handler. It even provides a suggestion to fix it!app.get(&quot;/users/:userId/posts/:postId&quot;, (req, res) =&amp;gt; { const userId = req.params.userId; const postId = req.params.postld; res.send(`Requested post ${postId} from user ${userId}`);}); Property &#39;postld&#39; does not exist on type &#39;PathArgs&amp;lt;&quot;/users/:userId/posts/:postId&quot;&amp;gt;&#39;. Did you mean &#39;postId&#39;?Dispatching ActionsIt’s a common pattern in many applications to represent actions in the system as values. This lets you easily track history, pass the actions over a network, and make code easier to test. The types to represent our actions might look something like this.type BakeBrownies = { tag: &quot;BAKE_BROWNIES&quot;, quantity: number };type EatBrownie = { tag: &quot;EAT_BROWNIE&quot; };type Action = BakeBrownies | EatBrownie;Eventually we need to do something with these action objects, so let’s write a simple class to handle them.class BrownieCounter { brownieCount = 0; bakeBrownies(action: BakeBrownies): void { this.brownieCount += action.quantity; } eatBrownie(action: EatBrownie): void { if (this.brownieCount &amp;gt; 0) { console.log(&quot;Om nom nom&quot;); this.brownieCount -= 1; } else { console.log(&quot;Noooooo!&quot;); } }}To glue them together, we’ll need a function which takes the action and passes it to the correct method of our BrownieCounter.function dispatchAction(brownieCounter: BrownieCounter, action: Action): void { switch (action.tag) { case &quot;BAKE_BROWNIES&quot;: brownieCounter.bakeBrownies(action); break; case &quot;EAT_BROWNIE&quot;: brownieCounter.eatBrownie(action); break; }}This is ok for now, but as we add more actions to our program, it’s going to get annoying having to add a new case for every one. Since the method names on our BrownieCounter are just camel case versions of the action tags, we can rewrite dispatchAction to generate the method name and call it. We just need a little snakeCaseToCamelCase helper function.function dispatchAction(brownieCounter: BrownieCounter, action: Action): void { (brownieCounter as any)[snakeCaseToCamelCase(action.tag)](action);}function snakeCaseToCamelCase(snakeCaseString: string): string { return ( snakeCaseString .split(&quot;_&quot;) .map((word, i) =&amp;gt; i === 0 ? word.toLowerCase() : word &amp;amp;&amp;amp; (word[0].toUpperCase() + word.slice(1).toLowerCase()) ) .join(&quot;&quot;) );}This avoids the boilerplate, but it’s a step backwards for type safety. As the type signature of snakeCaseToCamelCase only says it returns a string, the compiler has no way to know whether that string will be a valid method name for BrownieCounter, so we have to cast to any to allow it. Even worse, if we add a new action to the program, but forget to add a method to BrownieCounter to handle it, we won’t get a type error. It will not be until runtime that we see this sad message. brownieCounter[snakeCaseToCamelCase(...)] is not a functionLuckily, with TypeScript 4.1, we no longer need to choose between boilerplate and type safety. Using template literal types we can reimplement our case conversion at the type level. This requires another handy new feature - four new types for manipulating string literal types called Uppercase, Lowercase, Capitalize and Uncapitalize.type SnakeCaseToCamelCase&amp;lt;S extends string&amp;gt; = S extends `${infer FirstWord}_${infer Rest}` ? `${Lowercase&amp;lt;FirstWord&amp;gt;}${SnakeCaseToPascalCase&amp;lt;Rest&amp;gt;}` : `${Lowercase&amp;lt;S&amp;gt;}`;type SnakeCaseToPascalCase&amp;lt;S extends string&amp;gt; = S extends `${infer FirstWord}_${infer Rest}` ? `${Capitalize&amp;lt;Lowercase&amp;lt;FirstWord&amp;gt;&amp;gt;}${SnakeCaseToPascalCase&amp;lt;Rest&amp;gt;}` : Capitalize&amp;lt;Lowercase&amp;lt;S&amp;gt;&amp;gt;;type BakeBrowniesCamelCase = SnakeCaseToCamelCase&amp;lt;&quot;BAKE_BROWNIES&quot;&amp;gt;;// = &quot;bakeBrownies&quot;We can use this fancy new type to provide a more informative signature for our helper function.function snakeCaseToCamelCase&amp;lt;S extends string&amp;gt;( snakeCaseString: S,): SnakeCaseToCamelCase&amp;lt;S&amp;gt; { return ( snakeCaseString .split(&quot;_&quot;) .map((word, i) =&amp;gt; i === 0 ? word.toLowerCase() : word &amp;amp;&amp;amp; (word[0].toUpperCase() + word.slice(1).toLowerCase()) ) .join(&quot;&quot;) ) as SnakeCaseToCamelCase&amp;lt;S&amp;gt;}const tag = snakeCaseToCamelCase(&quot;BAKE_BROWNIES&quot;);// has type &quot;bakeBrownies&quot;This lets us remove the unsafe type cast from dispatchAction.function dispatchAction(brownieCounter: BrownieCounter, action: Action): void { brownieCounter[snakeCaseToCamelCase(action.tag)](action as any);}Unfortunately we still need to cast the action to any, as the compiler isn’t quite smart enough to figure out that we’ve picked the right method for handling the action. Still, it’s a big improvement. If we forget to add a method to BrownieCounter for a new action, we’ll get a nice clear error message pointing out our mistake.type StealBrownie = { tag: &quot;STEAL_BROWNIE&quot; };type Action = BakeBrownies | EatBrownie | StealBrownie; Property &#39;stealBrownie&#39; does not exist on type &#39;BrownieCounter&#39;.Success!A SQL DatabaseThese small examples are all well and good, but surely you couldn’t use this technique to interpret something as complex as a SQL query?Actually, you could. I know because Charles Pick of codemix has done just that. It’s a brilliant demonstration of the power of the type system, but I wouldn’t go uninstalling PostgreSQL just yet.That’s All FolksI hope you enjoyed this dive into the world of template literal types.If you’ve spotted any errors in this post, please let me know by opening an issue on GitHub." } ]
